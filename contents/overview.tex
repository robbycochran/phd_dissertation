
\newcommand{\execTrace}[1]{\ensuremath{\mathrm{T}_{#1}}\xspace}
\newcommand{\program}[1]{\ensuremath{\mathrm{P}_{#1}}\xspace}
\newcommand{\server}[1]{\ensuremath{\mathrm{S}_{#1}}\xspace}
\newcommand{\clockTrace}[1]{\ensuremath{\mathrm{C}_{#1}}\xspace}
\newcommand{\memoryTrace}[1]{\ensuremath{\mathrm{V}_{#1}}\xspace}
\newcommand{\replayLog}[1]{\ensuremath{\mathrm{R}_{#1}}\xspace}
\newcommand{\lang}[1]{\ensuremath{\mathrm{L}_{#1}}\xspace}
\newcommand{\msgLang}[1]{\ensuremath{\mathrm{L}_{M}}\xspace}
\newcommand{\machine}[1]{\ensuremath{{\Lambda}_{R#1}}\xspace}
\newcommand{\symMachine}[1]{\ensuremath{\mathrm{\Lambda}_{SE#1}}\xspace}
\newcommand{\messageTrace}[1]{\ensuremath{\mathrm{M}_{#1}}\xspace}
\newcommand{\messageTraceAlt}[1]{\ensuremath{\mathrm{\hat{M}_{#1}}}\xspace}

\chapter{Overview of Client Verification}
\label{ch:overview}

%\begin{definition}
%  An execution trace \execTrace{} is a sequence of machine or
%  bytecode instructions.
%\end{definition}
%
%%\begin{definition}
%%  A language \lang{P} presents the set of all execution
%%  traces \execTrace{} that may be generated by some program $P$.
%%\end{definition}
%
%It is generally not feasible to represent \lang{P}, so 
%existing techniques build a determine if an execution trace \execTrace{} 
%fits a model 

\begin{definition}
  A message trace  is a sequence of messages $\msg{0},
  \msg{1}, \ldots$ corresponding to calls to \posixSend or to
  \posixRecv in some client program \program{} communicating with a server
  program \server{}. That is, some messages in
  were sent from the client to the server, and some
  were sent from the server to the client. The messages are ordered
  from client's perspective.
\end{definition}

%\begin{definition}
%  A language \msgLang{\program{}} presents the set of all possible message
%  traces \messageTrace{} that can be observed, from the client's
%  perspective, during a client-server
%  session.
%\end{definition}

\begin{definition}
  Client behavior verification is a decision procedure that takes as input a
  program \program{} and a message trace $\msg{0},
  \msg{1}, \ldots$ \msg{\msgNmbr} and outputs
  if the message trace \messageTrace{\msgNmbr} is in
  \msgLang{\program{}},
  where \msgLang{\program{}} is the set of all messages
  traces that could be generated by some client program \program{}
  and some server program \server{}.
\end{definition}

Under client verification, an attacker may only submit a message trace
if it exists in \msgLang{\program}. This security
model reduces the power of the attacker, but does not guarantee that
there does not exist an attack message trace $\messageTraceAlt{} \in
\msgLang{\program{}}$.

Enumerating \msgLang{\program{}} in the general case is not feasible, but we show in this
dissertation that client behavior verification can be achieved.

In this \dissertation we take two approaches to client behavior
verification, in the first (\chref{ch:scv}) we determine if a message
trace is in \msgLang{\program}, incrementally, using symbolic
constraints, generated by executing a subset of paths in a modified
version of the client program. These accumulated constraints represent
a subset of \msgLang{\program}. Our second approach, described in
\chref{ch:guided} and extended in \chref{ch:parallel}, searches for an
execution trace \execTrace{} that can be used to show that a message
trace is a member of \msgLang{\program}.

%\begin{definition}
%  An execution trace \execTrace{} is a sequence of machine or
%  bytecode instructions.
%\end{definition}

%\begin{definition}
%  A language \lang{P} presents the set of all execution
%  traces \execTrace{} that may be generated by some program $P$.
%\end{definition}
%
%\begin{definition}
%  An replay log is a tuple $\replayLog{} = (\execTrace{},
%  \memoryTrace{} )$ where \execTrace{} is a execution
%  trace and \memoryTrace{} is a set of values such that
%  $|\execTrace{}| = |\memoryTrace{}|$. The ith
%  instruction in \execTrace{} occurred at time equal to the ith time
%  in \clockTrace{} and if it was a memory load, the instruction loaded
%  the value in \memoryTrace{}. A replay log can be used to replay an
%  execution precisely, including any values that were read from
%  hardware, such as random numbers or interrupt driven inputs (e.g.,
%  keyboard or mouse).
%\end{definition}
%
%\begin{definition}
%  A procedure \machine{} is a program that takes as input
%  a replay log \replayLog{}, replays each tuple in \replayLog{}
%  and emits a message trace \messageTrace{} representing all
%  calls to \posixSend and \posixRecv in the execution trace.
%\end{definition}
%
%\begin{definition}
%  Replay client verification is a decision procedure that takes as
%  input, a program \program{}, a replay log \replayLog{} and a message
%  trace \messageTrace{} and outputs valid if the execution trace
%  \execTrace{} is in \lang{\program{}} and
%  $\machine{}(\replayLog{})$ emits a \messageTraceAlt{} such that
%  $\messageTraceAlt{} = \messageTrace{}$.
%\end{definition}
%
%Under replay client verification, all clients must submit a replay log
%to the server at the end of a session. This way, a server can verify 
%a client's message trace, without enumerating all members of
%\msgLang{\program}. This model is equivalent to client verification.

We implement the client behavior decision procedure using symbolic
execution. One could conceivably use symbolic execution to 

\begin{definition}
  A procedure \symMachine{} is a program that takes as input
  an execution trace \execTrace{} and uses symbolic execution
  to replay \execTrace{}, using symbolic values for any loads from
  uninitialized memory and 
  emits a symbolic message trace \messageTrace{}
  and associated conditions for each of the branch instructions in
  \execTrace{}.
\end{definition}

\begin{definition}
  Symbolic client verification is a decision procedure that takes as
  input, a program \program{}, a execution trace \execTrace{} and a message
  trace \messageTrace{} and outputs valid if the execution trace
  \execTrace{} is in \lang{\program{}} and
  $\symMachine{}(\replayLog{})$ emits a \messageTraceAlt{} such that
  $\messageTraceAlt{} = \messageTrace{}$ is satisfiable.
\end{definition}

Under symbolic client verification, no additional demands are
made on the client. 

\begin{definition}
  An execution prefix \execPrefix{} is a prefix of an execution
  trace \execTrace{} that is valid according to symbolic client
  verification for a prefix of some  message trace \messageTrace{}.
\end{definition}

\section{Server-side Program Anomaly Detection}
A common defense against attackers is program anomaly detection.
Program anomaly detection analyzes program behavior and determines
whether the execution of a program is behaving as expected under
normal operation. There are numerous approaches... The server software
is monitored to generate an \execTrace{} for 

%Outline:
%
%Introduction (4-5 pages)
%- Motivation (games)
%- Problem
%- Solution
%- Contributions
%- Outline
%
%Overview and Background
%- Symbolic Execution
%- Related Work
%
%Exhaustive Client Verification
%- Motivation
%- Algorithm
%- Evaluation
% - Xpilot
%  - Special Consideration: Message Loss
% - Capman
%  - Special Consideration: Backtracking
% - Tetrinet
%  - Special Consideration: Bandwidth
%
%Optimistic Client Verification
%- Motivation
%- Algorithm
% - Paths
% - Training
% - Edit Distance
%- Evaluation
% - Xpilot
% - Tetrinet
%
%Parallel Optimistic Client Verification
%- Motivation
%- Algorithm
%- Evaluation
% - Xpilot
% - Tetrinet
%
%Conclusion
